---
title: Consensus
description: The Consensus layer of the Internet Computer
---

## Summary

The consensus algorithm consistently orders transactions for each replica of the same subnet. This guarantees that replicas executes them in the same way and therefore maintain a coherent replicated state. Consensus is reached by using a blockchain.

## Implementation

In order to get an overview of the consensus algorithm of the Internet Computer, make sure to read [this](https://medium.com/dfinity/achieving-consensus-on-the-internet-computer-ee9fbfbafcbc) post.

The Internet Computer uses a consensus algorithm called Internet Computer Consensus (ICC), which is composed of four main consensus subcomponents:

- [random beacon maker](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L220C34-L225C14): produces randomness
- [block maker](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L241C26-L254C14): creates candidate blocks
- [notary](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L201C21-L209C14): identifies valid blocks that could potentially be part of the blockchain
- [finalizer](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L210C24-L219C15): determines when a block can be executed

The ICC algorithm consists of an [artifact processor thread loop](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/artifact_manager/src/lib.rs#L268C1-L334C2) which at most every `ARTIFACT_MANAGER_TIMER_DURATION_MSEC` calls [process_changes](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/artifact_manager/src/lib.rs#L323C30-L323C100) of the `ArtifactProcessor`. This triggers the [on_state_change](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L421C5-L421C55) method of `ConsensusImpl`, which [calls](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L524C9-L537C57) the consensus subcomponents in a specific order and returns the [changes to be applied](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/artifact_manager/src/processors.rs#L69C1-L70C1) to the artifact pool.

We can now focus on the main subcomponents. The order in which they are called [matters](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L409C5-L420C70) but here we describe them as more convenient to the discussion.

### Random Beacon Maker

At each [height](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/random_beacon_maker.rs#L44C9-L44C50) of the blockchain, the hash of the previous random beacon and the next height are used to create the [content of the next following random beacon](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/random_beacon_maker.rs#L74C17-L75C99). The content is [signed](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/random_beacon_maker.rs#L86C27-L86C84) by the replica and used to create a `RandomBeaconShare` which is returned to the consensus thread loop and [added to the validated section of the artifact pool](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus.rs#L503C17-L506C18), so that it can be broadcast to other replicas.

The random value generated by the random beacon is used to specify an order (rank) in which replicas should propose a block at a certain height. This is done in order to reduce the number of valid blocks that are proposed at each height (facilitating finalization) and so that in case malicious replicas propose invalid blocks or simply do not not propose anything, another honest replica can propose its own valid block in a timely manner.

### Block Maker

The block maker subcomponent takes care of collecting validated transactions into the payload of a block by calling the [build_batch_payload](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/block_maker.rs#L423C5-L444C6) method of the `PayloadBuilder`.

The block maker is also responsible to check the [conditions](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/block_maker.rs#L126C17-L136C22) necessary for the block to be [proposed](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/block_maker.rs#L138C21-L148C23). The main consideration that is taken into account is whether it is [time to make a block](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/block_maker.rs#L128C24-L128C45) and this depends on the rank given to the replica by the random beacon. Honest replicas will propose a block only if [no other block of lower rank has been proposed](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/block_maker.rs#L127C24-L127C84) and guarantee that each of them will [propose at most one block for each height](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/block_maker.rs#L126C20-L126C63). These last conditions help reducing the number of valid blocks that are proposed in each round.

### Notary

The notary subcomponent is used to vote which blocks a replica considers valid for a certain height. The notary expresses its vote by broadcasting a [notarization share for each block it considers valid](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L158C5-L176C6).

However, it does not necessarily do so for every single valid block it receives. Each time the notary is triggered, it checks the [lowest rank block](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L91C1-L92C1) in its validated section of the artifact pool. It creates a notarization share for such a block only if it is [time to notarize](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L92C17-L92C94) a block for the given rank and if it [hasnâ€™t yet notarized](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L93C21-L93C84) that block.

The [time_to_notarize](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L106C5-L129C6) method gets the [amount of time since the start of the current round](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L114C9-L121C12) (height) that [must pass](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L124C13-L124C59) before creating a notarization share for a block of a [certain rank](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L112C9-L112C20). This is done to make facilitate the notarization of lower rank blocks. In case this does not happen (because of poor network conditions or malicious low-ranked replicas), higher-ranked blocks will be notarized after a delay proportional to their rank.

A block that received at least `n-f` notarization shares is said to be notarized and can thus be considered for inclusion in the blockchain.

### Finalizer

Due to the [notarization logic](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/notary.rs#L90C13-L101C14), there might be multiple notarized blocks at the same height. However, only one of these can become part of the blockchain. The finalizer takes care of consistently choosing the blocks that are part of the blockchain, one for each height. It does so by voting which block should become finalized by broadcasting a [finalization share](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/finalizer.rs#L230C14-L230C54). A block that received `n-f` finalization shares is considered finalized and becomes part of the blockchain.

At a given height, the [pick_block_to_finality_sign](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/finalizer.rs#L159C5-L159C101) of `Finalizer` is triggered to determine whether a block at that height can be finalized. The rules for creating a finalization share are the following:

- create [at most one finalization share for each height](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/finalizer.rs#L171C9-L178C10)
- create a finalization share only if there is a [single notarized block at a given height](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/finalizer.rs#L183C9-L199C11) and if the replica did [not send notarization share for other blocks at the same height](https://github.com/dfinity/ic/blob/7eace38b7580dc35af53b9180ea40480af4977dc/rs/consensus/src/consensus/finalizer.rs#L201C9-L208C10)

The rules for creating finalization shares (and thus for finalizing blocks) imply that not for every height there might be an explicitly finalized block (in the sense that it received at least `n-f` finalization share). However, as soon as a block becomes explicitly finalized, all its ancestor blocks become implicitly finalized.
